<!DOCTYPE html>
<html>
<head>
    <title>ä¸»æ’­ç«¯ (Broadcaster)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f0f2f5; color: #333; }
        h1 { color: #1a73e8; }
        video { border: 2px solid #ccc; border-radius: 8px; width: 520px; height: 390px; background: #000; display: block; margin-bottom: 15px;}
        .controls button, .controls input { margin: 5px; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; font-size: 14px; }
        .controls button { background-color: #1a73e8; color: white; }
        .controls button:hover { background-color: #155ab6; }
        .controls input { border: 1px solid #ccc; padding: 9px; }
        #logs { white-space: pre-wrap; font-family: monospace; background: #fff; padding: 15px; border: 1px solid #ddd; border-radius: 5px; max-height: 300px; overflow-y: auto; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>ä¸»æ’­ç«¯ (Broadcaster)</h1>
    <video id="localVideo" autoplay muted playsinline></video>
    <div class="controls">
        <button id="startButton">å¼€å§‹ç›´æ’­</button>
        <button id="stopButton">ç»“æŸç›´æ’­</button>
        <hr>
        <button id="muteButton">é™éŸ³</button>
        <button id="unmuteButton">å–æ¶ˆé™éŸ³</button>
        <br>
        <button id="likeButton">ç‚¹èµ</button>
        <button id="giftButton">é€ç¤¼ç‰©</button>
        <br>
        <input type="text" id="chatInput" placeholder="è¾“å…¥å¼¹å¹•...">
        <button id="sendChatButton">å‘é€å¼¹å¹•</button>
    </div>
    <h3>äº‹ä»¶æ—¥å¿—:</h3>
    <div id="logs"></div>

    <script>
        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const muteButton = document.getElementById('muteButton');
        const unmuteButton = document.getElementById('unmuteButton');
        const likeButton = document.getElementById('likeButton');
        const giftButton = document.getElementById('giftButton');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const logs = document.getElementById('logs');

        // --- Global State ---
        let localStream;
        const peerConnections = new Map();
        const dataChannels = new Map();
        const ws = new WebSocket('wss://live-test-a52n.onrender.com'); // Connect to public server

        const STUN_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // --- Logging ---
        function log(message) {
            console.log(message);
            logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            logs.scrollTop = logs.scrollHeight;
        }

        // --- WebSocket Event Handling ---
        ws.onopen = () => {
            log('ğŸ“¡ å·²æˆåŠŸè¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨ã€‚');
            // Register as the broadcaster once the media is ready.
            // This is now handled by the 'startButton'.
        };

        ws.onerror = (error) => log(`âŒ WebSocket è¿æ¥é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}ã€‚`);

        ws.onmessage = async event => {
            const message = JSON.parse(event.data);
            const { type, payload } = message;
            log(`ğŸ“© æ”¶åˆ°ä¿¡ä»¤æ¶ˆæ¯: ${type}`);

            switch (type) {
                case 'new-viewer':
                    // A new viewer has connected, create a peer connection for them
                    createPeerConnection(payload.viewerId);
                    break;
                case 'answer':
                    // Received an answer from a viewer
                    handleAnswer(payload);
                    break;
                case 'candidate':
                    // Received an ICE candidate from a viewer
                    handleCandidate(payload);
                    break;
                case 'viewer-disconnected':
                    log(`ğŸ‘‹ è§‚ä¼— ${payload.viewerId} å·²æ–­å¼€è¿æ¥ã€‚`);
                    closePeerConnection(payload.viewerId);
                    break;
                default:
                    log(`âš ï¸ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${type}`);
            }
        };

        function sendMessage(message) {
            ws.send(JSON.stringify(message));
        }

        // --- WebRTC Core Functions ---
        async function createPeerConnection(viewerId) {
            if (!localStream) {
                log('âŒ æœ¬åœ°åª’ä½“æµæœªå°±ç»ªï¼Œæ— æ³•ä¸ºè§‚ä¼—åˆ›å»ºè¿æ¥ã€‚');
                return;
            }
            log(`âœ¨ ä¸ºæ–°è§‚ä¼— ${viewerId} åˆ›å»º PeerConnection...`);

            const pc = new RTCPeerConnection(STUN_SERVERS);
            peerConnections.set(viewerId, pc);

            // Add local stream tracks to the connection
            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            
            // Create data channel for this viewer
            const dc = pc.createDataChannel('chat');
            dc.onopen = () => log(`ğŸ’¬ ä¸è§‚ä¼— ${viewerId} çš„æ•°æ®é€šé“å·²å¼€å¯ã€‚`);
            dc.onclose = () => log(`ğŸ’¬ ä¸è§‚ä¼— ${viewerId} çš„æ•°æ®é€šé“å·²å…³é—­ã€‚`);
            dataChannels.set(viewerId, dc);

            // Handle ICE candidates
            pc.onicecandidate = event => {
                if (event.candidate) {
                    sendMessage({
                        type: 'candidate',
                        payload: {
                            targetId: viewerId,
                            candidate: event.candidate
                        }
                    });
                }
            };
            
            pc.onconnectionstatechange = () => {
                log(`ğŸ”„ ä¸è§‚ä¼— ${viewerId} çš„è¿æ¥çŠ¶æ€: ${pc.connectionState}`);
            };

            // Create and send offer
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            log(`â¬†ï¸ ä¸ºè§‚ä¼— ${viewerId} å‘é€ Offer...`);
            sendMessage({
                type: 'offer',
                payload: {
                    targetId: viewerId,
                    offer: offer
                }
            });
        }
        
        function handleAnswer(payload) {
            const { senderId, answer } = payload;
            const pc = peerConnections.get(senderId);
            if (pc) {
                log(`ğŸ¤ æ”¶åˆ°è§‚ä¼— ${senderId} çš„ Answerï¼Œæ­£åœ¨è®¾ç½®è¿œç«¯æè¿°...`);
                pc.setRemoteDescription(new RTCSessionDescription(answer));
            }
        }

        function handleCandidate(payload) {
            const { senderId, candidate } = payload;
            const pc = peerConnections.get(senderId);
            if (pc) {
                log(`ğŸ“ æ”¶åˆ°è§‚ä¼— ${senderId} çš„ ICE Candidateï¼Œæ­£åœ¨æ·»åŠ ...`);
                pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
        }

        function closePeerConnection(viewerId) {
            const pc = peerConnections.get(viewerId);
            if (pc) {
                pc.close();
                peerConnections.delete(viewerId);
            }
            const dc = dataChannels.get(viewerId);
            if (dc) {
                dataChannels.delete(viewerId);
            }
        }

        // --- UI Event Handlers ---
        startButton.onclick = async () => {
            if (!localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    localVideo.srcObject = localStream;
                    log('âœ… æ‘„åƒå¤´å’Œéº¦å…‹é£å·²å°±ç»ªã€‚');
                } catch (e) {
                    log(`âŒ è·å–åª’ä½“è®¾å¤‡å¤±è´¥: ${e.toString()}ã€‚`);
                    alert('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®ã€‚');
                    return;
                }
            }
            log('â–¶ï¸ å¼€å§‹ç›´æ’­ï¼Œæ­£åœ¨å‘ä¿¡ä»¤æœåŠ¡å™¨æ³¨å†Œ...');
            sendMessage({ type: 'register', payload: { role: 'broadcaster' } });
            startButton.disabled = true;
            stopButton.disabled = false;
        };

        stopButton.onclick = () => {
            log('â¹ï¸ ç›´æ’­ç»“æŸï¼Œæ­£åœ¨å…³é—­æ‰€æœ‰è¿æ¥...');
            peerConnections.forEach((pc, viewerId) => {
                closePeerConnection(viewerId);

            });
            sendMessage({type: 'stop-broadcasting'}); // Notify server
            ws.close();
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            log('â¹ï¸ æ‰€æœ‰è¿æ¥å·²å…³é—­ï¼Œç›´æ’­å·²åœæ­¢ã€‚');
        };

        // --- Data Channel Broadcasting ---
        function broadcastDataChannelMessage(type, payload) {
            const message = JSON.stringify({ type, payload });
            log(`ğŸ“¤ (å¹¿æ’­æ•°æ®é€šé“æ¶ˆæ¯) ${type}`);
            dataChannels.forEach(dc => {
                if (dc.readyState === 'open') {
                    dc.send(message);
                }
            });
        }

        muteButton.onclick = () => {
            if(localStream) localStream.getAudioTracks()[0].enabled = false;
            broadcastDataChannelMessage('live.anchor.mute');
        };
        
        unmuteButton.onclick = () => {
            if(localStream) localStream.getAudioTracks()[0].enabled = true;
            broadcastDataChannelMessage('live.anchor.unmute');
        };

        likeButton.onclick = () => broadcastDataChannelMessage('live.like', { user: 'ä¸»æ’­' });
        
        giftButton.onclick = () => broadcastDataChannelMessage('live.gift.send', { user: 'ä¸»æ’­', gift: 'ç«ç®­', count: 1 });
        
        sendChatButton.onclick = () => {
            if (chatInput.value) {
                broadcastDataChannelMessage('live.chat.message', { user: 'ä¸»æ’­', text: chatInput.value });
                chatInput.value = '';
            }
        };

        // Initial state
        stopButton.disabled = true;
    </script>
</body>
</html>