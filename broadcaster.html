<!DOCTYPE html>
<html>
<head>
    <title>ä¸»æ’­ç«¯ (Broadcaster)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f0f2f5; color: #333; }
        h1, h3 { color: #1a73e8; }
        video { border: 2px solid #ccc; border-radius: 8px; width: 520px; height: 390px; background: #000; display: block; margin-bottom: 15px;}
        .controls button, .controls input { margin: 5px; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; font-size: 14px; }
        .controls button { background-color: #1a73e8; color: white; }
        .controls button:hover { background-color: #155ab6; }
        .controls input { border: 1px solid #ccc; padding: 9px; }
        #logs, #viewer-list-container { white-space: pre-wrap; font-family: monospace; background: #fff; padding: 15px; border: 1px solid #ddd; border-radius: 5px; max-height: 300px; overflow-y: auto; margin-top: 20px; }
        .viewer-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; border-bottom: 1px solid #eee; }
        .viewer-item button { 
            background-color: #1a73e8; 
            color: white; 
            padding: 10px 15px; 
            font-size: 14px; 
            border-radius: 5px; 
            border: none; 
            cursor: pointer; 
            margin: 2px; /* Add a small margin for spacing */
        }
        .viewer-item button:hover { background-color: #155ab6; }
    </style>
</head>
<body>
    <h1>ä¸»æ’­ç«¯ (Broadcaster)</h1>
    <video id="localVideo" autoplay muted playsinline></video>
    <div class="controls">
        <button id="startButton">å¼€å§‹ç›´æ’­</button>
        <button id="stopButton">ç»“æŸç›´æ’­</button>
        <hr>
        <button id="muteButton">é™éŸ³</button>
        <button id="unmuteButton">å–æ¶ˆé™éŸ³</button>
        <br>
        <button id="likeButton">ç‚¹èµ</button>
        <button id="giftButton">é€ç¤¼ç‰©</button>
        <br>
        <input type="text" id="chatInput" placeholder="è¾“å…¥å¼¹å¹•...">
        <button id="sendChatButton">å‘é€å¼¹å¹•</button>
    </div>

    <h3>åœ¨çº¿è§‚ä¼—:</h3>
    <div id="viewer-list-container">
        <div id="viewer-list"></div>
    </div>

    <h3>äº‹ä»¶æ—¥å¿—:</h3>
    <div id="logs"></div>

    <script>
        // DOM Elements
        const localVideo = document.getElementById('localVideo');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const muteButton = document.getElementById('muteButton');
        const unmuteButton = document.getElementById('unmuteButton');
        const likeButton = document.getElementById('likeButton');
        const giftButton = document.getElementById('giftButton');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const logs = document.getElementById('logs');
        const viewerListDiv = document.getElementById('viewer-list');

        // --- Global State ---
        let localStream;
        const viewers = new Map(); // Stores viewerId -> { username, pc, dc }
        const ws = new WebSocket('wss://live-test-a52n.onrender.com'); // Connect to public server

        const STUN_SERVERS = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // --- Logging & UI Update ---
        function log(message) {
            console.log(message);
            logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            logs.scrollTop = logs.scrollHeight;
        }

        function updateViewerList() {
            viewerListDiv.innerHTML = '';
            if(viewers.size === 0) {
                viewerListDiv.innerHTML = 'æš‚æ— è§‚ä¼—';
                return;
            }
            viewers.forEach((viewer, viewerId) => {
                const item = document.createElement('div');
                item.className = 'viewer-item';
                item.innerHTML = `
                    <span>${viewer.username} (${viewerId.substring(0, 4)})</span>
                    <div>
                        <button class="mute-btn" data-id="${viewerId}">ç¦è¨€</button>
                        <button class="kick-btn" data-id="${viewerId}">è¸¢äºº</button>
                    </div>
                `;
                viewerListDiv.appendChild(item);
            });
        }

        // --- WebSocket Event Handling ---
        ws.onopen = () => {
            log('ğŸ“¡ å·²æˆåŠŸè¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨ã€‚');
        };

        ws.onerror = (error) => log(`âŒ WebSocket è¿æ¥é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}ã€‚`);

        ws.onmessage = async event => {
            const message = JSON.parse(event.data);
            const { type, payload } = message;
            log(`ğŸ“© æ”¶åˆ°ä¿¡ä»¤æ¶ˆæ¯: ${type}`);

            switch (type) {
                case 'new-viewer':
                    const { viewerId, username } = payload;
                    log(`ğŸ‘‹ live.audience.join â†’ è§‚ä¼— '${username}' (${viewerId}) å·²åŠ å…¥ã€‚`);
                    viewers.set(viewerId, { username: username });
                    updateViewerList();
                    createPeerConnection(viewerId, username);
                    break;
                case 'answer':
                    handleAnswer(payload);
                    break;
                case 'candidate':
                    handleCandidate(payload);
                    break;
                case 'viewer-disconnected':
                    const disconnectedViewer = viewers.get(payload.viewerId);
                    log(`ğŸ‘‹ live.audience.leave â†’ è§‚ä¼— '${disconnectedViewer ? disconnectedViewer.username : payload.viewerId}' å·²æ–­å¼€è¿æ¥ã€‚`);
                    closePeerConnection(payload.viewerId);
                    updateViewerList();
                    break;
                default:
                    log(`âš ï¸ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${type}`);
            }
        };

        function updateViewerList() {
            viewerListDiv.innerHTML = '';
            if(viewers.size === 0) {
                viewerListDiv.innerHTML = 'æš‚æ— è§‚ä¼—';
                return;
            }
            viewers.forEach((viewer, viewerId) => {
                const item = document.createElement('div');
                item.className = 'viewer-item';
                const muteButtonText = viewer.isMuted ? 'è§£é™¤ç¦è¨€' : 'ç¦è¨€';
                item.innerHTML = `
                    <span>${viewer.username} (${viewerId.substring(0, 4)})</span>
                    <div>
                        <button class="mute-btn" data-id="${viewerId}">${muteButtonText}</button>
                        <button class="kick-btn" data-id="${viewerId}">è¸¢äºº</button>
                    </div>
                `;
                viewerListDiv.appendChild(item);
            });
        }

        // --- WebSocket Event Handling ---
        ws.onopen = () => {
            log('ğŸ“¡ å·²æˆåŠŸè¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨ã€‚');
        };

        ws.onerror = (error) => log(`âŒ WebSocket è¿æ¥é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}ã€‚`);

        ws.onmessage = async event => {
            const message = JSON.parse(event.data);
            const { type, payload } = message;
            log(`ğŸ“© æ”¶åˆ°ä¿¡ä»¤æ¶ˆæ¯: ${type}`);

            switch (type) {
                case 'new-viewer':
                    const { viewerId, username } = payload;
                    log(`ğŸ‘‹ live.audience.join â†’ è§‚ä¼— '${username}' (${viewerId}) å·²åŠ å…¥ã€‚`);
                    viewers.set(viewerId, { username: username, isMuted: false });
                    updateViewerList();
                    createPeerConnection(viewerId, username);
                    break;
                case 'answer':
                    handleAnswer(payload);
                    break;
                case 'candidate':
                    handleCandidate(payload);
                    break;
                case 'viewer-disconnected':
                    const disconnectedViewer = viewers.get(payload.viewerId);
                    log(`ğŸ‘‹ live.audience.leave â†’ è§‚ä¼— '${disconnectedViewer ? disconnectedViewer.username : payload.viewerId}' å·²æ–­å¼€è¿æ¥ã€‚`);
                    closePeerConnection(payload.viewerId);
                    updateViewerList();
                    break;
                default:
                    log(`âš ï¸ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${type}`);
            }
        };

        function sendMessage(message) {
            ws.send(JSON.stringify(message));
        }
        
        // --- WebRTC Core Functions ---
        async function createPeerConnection(viewerId, username) {
            if (!localStream) {
                log('âŒ æœ¬åœ°åª’ä½“æµæœªå°±ç»ªï¼Œæ— æ³•ä¸ºè§‚ä¼—åˆ›å»ºè¿æ¥ã€‚');
                return;
            }
            log(`âœ¨ ä¸ºæ–°è§‚ä¼— '${username}' (${viewerId}) åˆ›å»º PeerConnection...`);

            const pc = new RTCPeerConnection(STUN_SERVERS);
            
            const viewerInfo = viewers.get(viewerId);
            viewerInfo.pc = pc;

            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            
            const dc = pc.createDataChannel('chat');
            dc.onopen = () => log(`ğŸ’¬ ä¸è§‚ä¼— '${username}' çš„æ•°æ®é€šé“å·²å¼€å¯ã€‚`);
            dc.onclose = () => log(`ğŸ’¬ ä¸è§‚ä¼— '${username}' çš„æ•°æ®é€šé“å·²å…³é—­ã€‚`);
            dc.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'live.chat.message') {
                    log(`ğŸ’¬ [${msg.payload.user}]: ${msg.payload.text}`);
                }
            };
            viewerInfo.dc = dc;

            pc.onicecandidate = event => {
                if (event.candidate) {
                    sendMessage({
                        type: 'candidate',
                        payload: { targetId: viewerId, candidate: event.candidate }
                    });
                }
            };
            
            pc.onconnectionstatechange = () => {
                log(`ğŸ”„ ä¸è§‚ä¼— '${username}' çš„è¿æ¥çŠ¶æ€: ${pc.connectionState}`);
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);

            log(`â¬†ï¸ ä¸ºè§‚ä¼— '${username}' å‘é€ Offer...`);
            sendMessage({
                type: 'offer',
                payload: { targetId: viewerId, offer: offer }
            });
        }
        
        function handleAnswer(payload) {
            const { senderId, answer } = payload;
            const viewerInfo = viewers.get(senderId);
            if (viewerInfo && viewerInfo.pc) {
                log(`ğŸ¤ æ”¶åˆ°è§‚ä¼— '${viewerInfo.username}' çš„ Answerï¼Œæ­£åœ¨è®¾ç½®è¿œç«¯æè¿°...`);
                viewerInfo.pc.setRemoteDescription(new RTCSessionDescription(answer));
            }
        }

        function handleCandidate(payload) {
            const { senderId, candidate } = payload;
            const viewerInfo = viewers.get(senderId);
            if (viewerInfo && viewerInfo.pc) {
                log(`ğŸ“ æ”¶åˆ°è§‚ä¼— '${viewerInfo.username}' çš„ ICE Candidateï¼Œæ­£åœ¨æ·»åŠ ...`);
                viewerInfo.pc.addIceCandidate(new RTCIceCandidate(candidate));
            }
        }

        function closePeerConnection(viewerId) {
            const viewerInfo = viewers.get(viewerId);
            if (viewerInfo) {
                if (viewerInfo.pc) viewerInfo.pc.close();
                viewers.delete(viewerId);
            }
        }

        // --- UI Event Handlers ---
        startButton.onclick = async () => {
            if (!localStream) {
                try {
                    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                    localVideo.srcObject = localStream;
                    log('âœ… live.ready â†’ ç›´æ’­åˆå§‹åŒ–å®Œæˆï¼Œæ‘„åƒå¤´å’Œéº¦å…‹é£å·²å°±ç»ªã€‚');
                } catch (e) {
                    log(`âŒ è·å–åª’ä½“è®¾å¤‡å¤±è´¥: ${e.toString()}ã€‚`);
                    alert('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®ã€‚');
                    return;
                }
            }
            log('â–¶ï¸ live.start â†’ å¼€å§‹ç›´æ’­ï¼Œæ­£åœ¨å‘ä¿¡ä»¤æœåŠ¡å™¨æ³¨å†Œ...');
            sendMessage({ type: 'register', payload: { role: 'broadcaster', username: 'ä¸»æ’­' } });
            startButton.disabled = true;
            stopButton.disabled = false;
        };

        stopButton.onclick = () => {
            log('â¹ï¸ live.stop â†’ ç›´æ’­ç»“æŸï¼Œæ­£åœ¨å…³é—­æ‰€æœ‰è¿æ¥...');
            viewers.forEach((viewer, viewerId) => {
                closePeerConnection(viewerId);
});
            updateViewerList();
            sendMessage({type: 'stop-broadcasting'});
            ws.close();
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            startButton.disabled = false;
            stopButton.disabled = true;
            log('â¹ï¸ æ‰€æœ‰è¿æ¥å·²å…³é—­ï¼Œç›´æ’­å·²åœæ­¢ã€‚');
        };

        // --- Data Channel Broadcasting ---
        function broadcastDataChannelMessage(type, payload) {
            const message = JSON.stringify({ type, payload });
            log(`ğŸ“¤ (å¹¿æ’­æ•°æ®é€šé“æ¶ˆæ¯) ${type}`);
            viewers.forEach(viewer => {
                if (viewer.dc && viewer.dc.readyState === 'open') {
                    viewer.dc.send(message);
                }
            });
        }

        muteButton.onclick = () => {
            if(localStream) localStream.getAudioTracks()[0].enabled = false;
            broadcastDataChannelMessage('live.anchor.mute');
        };
        
        unmuteButton.onclick = () => {
            if(localStream) localStream.getAudioTracks()[0].enabled = true;
            broadcastDataChannelMessage('live.anchor.unmute');
        };

        likeButton.onclick = () => broadcastDataChannelMessage('live.like', { user: 'ä¸»æ’­' });
        
        giftButton.onclick = () => broadcastDataChannelMessage('live.gift.send', { user: 'ä¸»æ’­', gift: 'ç«ç®­', count: 1 });
        
        sendChatButton.onclick = () => {
            if (chatInput.value) {
                broadcastDataChannelMessage('live.chat.message', { user: 'ä¸»æ’­', text: chatInput.value });
                chatInput.value = '';
            }
        };

        // Initial state
        stopButton.disabled = true;
        updateViewerList();

        // --- Moderation Event Handling ---
        viewerListDiv.addEventListener('click', (event) => {
            const target = event.target;
            const viewerId = target.dataset.id;
            if (!viewerId) return;

            const viewerInfo = viewers.get(viewerId);
            if (!viewerInfo) return;

            if (target.classList.contains('kick-btn')) {
                if (confirm(`ç¡®å®šè¦å°†è§‚ä¼— ${viewerInfo.username} è¸¢å‡ºç›´æ’­é—´å—ï¼Ÿ`)) {
                    log(`ğŸ‘¢ æ­£åœ¨è¯·æ±‚æœåŠ¡å™¨å°†è§‚ä¼— ${viewerId} è¸¢å‡º...`);
                    sendMessage({
                        type: 'kick-user',
                        payload: { targetId: viewerId }
                    });
                }
            } else if (target.classList.contains('mute-btn')) {
                // Toggle mute state
                viewerInfo.isMuted = !viewerInfo.isMuted;
                
                const action = viewerInfo.isMuted ? 'mute-chat' : 'unmute-chat';
                log(`ğŸ’¬ æ­£åœ¨å‘è§‚ä¼— ${viewerInfo.username} å‘é€ '${action}' å‘½ä»¤...`);

                if (viewerInfo.dc && viewerInfo.dc.readyState === 'open') {
                    viewerInfo.dc.send(JSON.stringify({
                        type: 'moderation',
                        payload: { action: action }
                    }));
                } else {
                    log(`âŒ ä¸è§‚ä¼— ${viewerInfo.username} çš„æ•°æ®é€šé“æœªå¼€å¯ï¼Œæ— æ³•å‘é€ç¦è¨€å‘½ä»¤ã€‚`);
                }
                
                // Refresh the list to update button text
                updateViewerList();
            }
        });
    </script>
</body>
</html>