<!DOCTYPE html>
<html>
<head>
    <title>ä¸»æ’­ç«¯ (Broadcaster)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f0f2f5; color: #333; display: flex; gap: 20px; }
        .main-content { flex: 3; }
        .sidebar { flex: 1; background: #fff; padding: 15px; border-radius: 8px; border: 1px solid #ddd; }
        h1, h2, h3 { color: #1a73e8; }
        h2 { border-bottom: 2px solid #e0e0e0; padding-bottom: 5px; }
        video { border: 2px solid #ccc; border-radius: 8px; width: 100%; height: auto; background: #000; display: block; margin-bottom: 15px;}
        .controls button, .controls input { margin: 5px 0; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; font-size: 14px; width: calc(100% - 32px); }
        .controls button { background-color: #1a73e8; color: white; }
        .controls button:hover { background-color: #155ab6; }
        .controls button:disabled { background-color: #ccc; }
        .controls input { border: 1px solid #ccc; padding: 9px; }
        #logs { white-space: pre-wrap; font-family: monospace; background: #fff; padding: 15px; border: 1px solid #ddd; border-radius: 5px; max-height: 200px; overflow-y: auto; margin-top: 20px; }
        #userInfo, #roomInfo { background-color: #e3f2fd; padding: 10px; border-radius: 5px; margin-bottom: 15px; }
        .viewer-list li { display: flex; justify-content: space-between; align-items: center; padding: 5px; border-bottom: 1px solid #eee; }
        .viewer-list .viewer-actions button { /* Specific styles for buttons within viewer list actions */
            font-size: 12px;
            padding: 5px 10px;
            margin-left: 5px;
            width: auto; /* Override general button width */
        }
        .viewer-list .kick-button { background-color: #e74c3c; } /* Red for kick */
        .viewer-list .mute-button { background-color: #5bc0de; } /* Info blue for mute */
        .viewer-list .unmute-button { background-color: #f0ad4e; } /* Warning orange for unmute */
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
</head>
<body>
    <div class="main-content">
        <h1>ä¸»æ’­ç«¯ (Broadcaster)</h1>
        <div id="userInfo"></div>
        <div id="roomInfo" style="display:none;"></div>
        
        <video id="localVideo" autoplay muted playsinline></video>

        <div class="controls" id="roomCreationControls">
            <input type="text" id="roomNameInput" placeholder="è¾“å…¥æˆ¿é—´å...">
            <button id="createRoomButton">åˆ›å»ºå¹¶å¼€å§‹ç›´æ’­</button>
        </div>
        
        <div class="controls" id="inCallControls" style="display:none;">
            <button id="stopButton">ç»“æŸç›´æ’­</button>
            <hr>
            <button id="muteButton">é™éŸ³</button>
            <button id="unmuteButton">å–æ¶ˆé™éŸ³</button>
            <hr>
            <input type="text" id="chatInput" placeholder="è¾“å…¥å¼¹å¹•...">
            <button id="sendChatButton">å‘é€å¼¹å¹•</button>
        </div>
        <h3>äº‹ä»¶æ—¥å¿—:</h3>
        <div id="logs"></div>
    </div>
    <div class="sidebar">
        <h2>è§‚ä¼—åˆ—è¡¨</h2>
        <ul id="viewerList" class="viewer-list"></ul>
    </div>

    <script>
        // --- DOM Elements ---
        const localVideo = document.getElementById('localVideo');
        const logs = document.getElementById('logs');
        const userInfoDisplay = document.getElementById('userInfo');
        const roomInfoDisplay = document.getElementById('roomInfo');
        const viewerList = document.getElementById('viewerList');

        const roomCreationControls = document.getElementById('roomCreationControls');
        const inCallControls = document.getElementById('inCallControls');
        const roomNameInput = document.getElementById('roomNameInput');
        const createRoomButton = document.getElementById('createRoomButton');
        const stopButton = document.getElementById('stopButton');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');
        const muteButton = document.getElementById('muteButton');
        const unmuteButton = document.getElementById('unmuteButton');

        // --- App State ---
        let localStream;
        let peerConnections = new Map();
        let dataChannels = new Map();
        let userInfo = {};
        let roomInfo = {};
        let mutedViewersLocal = new Set(); // Local set of muted viewer persistentIds
        let isAnchorMuted = false; // New state for anchor's own mute status

        // --- Logging ---
        function log(message) {
            console.log(message);
            logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            logs.scrollTop = logs.scrollHeight;
        }

        // --- User & Room Initialization ---
        function initializeUser() {
            const storedUserInfo = localStorage.getItem('broadcasterUserInfo');
            if (storedUserInfo) {
                userInfo = JSON.parse(storedUserInfo);
            } else {
                const username = prompt("è¯·è¾“å…¥æ‚¨çš„ç”¨æˆ·å:", "ä¸»æ’­" + Math.floor(Math.random() * 1000));
                userInfo = { persistentId: uuid.v4(), username: username || "åŒ¿åä¸»æ’­" };
                localStorage.setItem('broadcasterUserInfo', JSON.stringify(userInfo));
            }
            userInfoDisplay.innerHTML = `<strong>ç”¨æˆ·:</strong> ${userInfo.username} <small>(ID: ${userInfo.persistentId.substring(0, 4)})</small>`;
        }
        
        // --- UI Update Functions ---
        function updateViewerList() {
            viewerList.innerHTML = '';
            peerConnections.forEach((pc, viewerId) => {
                const client = pc.clientInfo;
                if (!client) return;

                const isMuted = mutedViewersLocal.has(viewerId);
                const muteButtonText = isMuted ? 'è§£é™¤ç¦è¨€' : 'ç¦è¨€';
                const muteButtonClass = isMuted ? 'unmute-button' : 'mute-button';

                const li = document.createElement('li');
                li.innerHTML = `<span>${client.username} <small>(${viewerId.substring(0, 4)})</small></span>
                                <div class="viewer-actions">
                                    <button class="${muteButtonClass}" onclick="toggleMuteViewer('${viewerId}', ${isMuted})">${muteButtonText}</button>
                                    <button class="kick-button" onclick="kickUser('${viewerId}')">è¸¢å‡º</button>
                                </div>`;
                viewerList.appendChild(li);
            });
        }

        // --- Signaling Server Connection ---
        const ws = new WebSocket('wss://live-test-a52n.onrender.com');

        ws.onopen = () => {
            log('ğŸ“¡ è¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨ã€‚');
            ws.send(JSON.stringify({
                type: 'register',
                payload: { persistentId: userInfo.persistentId, username: userInfo.username }
            }));
        };

        ws.onerror = (error) => log(`âŒ WebSocket é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}ã€‚`);
        ws.onclose = () => {
            log('ğŸ”Œ ä¸æœåŠ¡å™¨çš„è¿æ¥å·²æ–­å¼€ã€‚');
            inCallControls.style.display = 'none';
            roomCreationControls.style.display = 'block';
            roomInfoDisplay.style.display = 'none';
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();
            dataChannels.clear();
            mutedViewersLocal.clear(); // Clear muted state on disconnect
            updateViewerList();
            localStream = null; // Reset local stream if it was active
            localVideo.srcObject = null;
            isAnchorMuted = false; // Reset anchor mute state
        };
        
        ws.onmessage = async event => {
            const message = JSON.parse(event.data);
            const fromId = message.payload?.senderId || message.payload?.viewerId || 'server';
            log(`ğŸ“© [${fromId.substring(0,4)}] â†’ ${message.type}`);

            switch (message.type) {
                case 'registered':
                    log(`âœï¸  ç”¨æˆ·æ³¨å†ŒæˆåŠŸ (ID: ${message.payload.userId.substring(0,4)})`);
                    break;
                case 'room-created':
                    roomInfo = { id: message.payload.roomId, name: message.payload.roomName };
                    roomInfoDisplay.innerHTML = `<strong>æˆ¿é—´:</strong> ${roomInfo.name} <small>(ID: ${roomInfo.id.substring(0, 4)})</small>`;
                    roomInfoDisplay.style.display = 'block';
                    roomCreationControls.style.display = 'none';
                    inCallControls.style.display = 'block';
                    log(`ğŸšª æˆ¿é—´ "${roomInfo.name}" åˆ›å»ºæˆåŠŸ!`);
                    break;
                case 'new-viewer':
                    handleNewViewer(message.payload);
                    break;
                case 'viewer-left':
                    handleViewerDisconnect(message.payload.viewerId);
                    break;
                case 'answer':
                    handleAnswer(message.payload);
                    break;
                case 'candidate':
                    handleCandidate(message.payload);
                    break;
                case 'viewer-muted-status': // Server tells us the mute status of a viewer
                    handleViewerMuteStatus(message.payload);
                    break;
            }
        };

        // --- WebRTC Handlers ---
        async function handleNewViewer(payload) {
            const { viewerId, username, isMuted } = payload; // isMuted will come from server
            log(`ğŸ‘€ æ–°è§‚ä¼—: ${username} (${viewerId.substring(0,4)})${isMuted ? ' (å·²ç¦è¨€)' : ''}`);
            
            if (!localStream) return log('âš ï¸ ä¸»æ’­å°šæœªå¼€æ’­!');

            const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
            pc.clientInfo = { id: viewerId, username: username }; // Attach info to PC object
            peerConnections.set(viewerId, pc);

            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            // Set the audio track enabled status based on current anchor mute state
            localStream.getAudioTracks().forEach(track => {
                track.enabled = !isAnchorMuted;
            });


            const dc = pc.createDataChannel(`chat-${viewerId}`);
            dc.onopen = () => log(`ğŸ’¬ ä¸ ${username} çš„æ•°æ®é€šé“å·²å¼€å¯ã€‚`);
            dc.onmessage = event => {
                const msg = JSON.parse(event.data);
                if (msg.type === 'live.chat.message') {
                    if (mutedViewersLocal.has(viewerId)) {
                        log(`ğŸ¤« [${msg.payload.user}] (è¢«ç¦è¨€) å°è¯•å‘é€: ${msg.payload.text}`);
                    } else {
                        log(`ğŸ’¬ [${msg.payload.user}] ${msg.payload.text}`);
                    }
                }
            };
            dataChannels.set(viewerId, dc);

            pc.onicecandidate = e => {
                if (e.candidate) {
                    ws.send(JSON.stringify({ type: 'candidate', payload: { targetId: viewerId, candidate: e.candidate }}));
                }
            };
            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
                    handleViewerDisconnect(viewerId);
                }
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            
            ws.send(JSON.stringify({ type: 'offer', payload: { targetId: viewerId, offer: offer }}));
            // If the viewer is already muted, add them to our local set
            if (isMuted) {
                mutedViewersLocal.add(viewerId);
            }
            updateViewerList();
        }

        function handleViewerDisconnect(viewerId) {
            const pc = peerConnections.get(viewerId);
            if (pc) {
                log(`ğŸ‘‹ è§‚ä¼— ${pc.clientInfo.username} å·²ç¦»å¼€ã€‚`);
                pc.close();
                peerConnections.delete(viewerId);
            }
            if (dataChannels.has(viewerId)) dataChannels.delete(viewerId);
            mutedViewersLocal.delete(viewerId); // Also remove from muted list
            updateViewerList();
        }
        
        async function handleAnswer({ senderId, answer }) {
            const pc = peerConnections.get(senderId);
            if (pc) await pc.setRemoteDescription(new RTCSessionDescription(answer));
        }

        async function handleCandidate({ senderId, candidate }) {
            const pc = peerConnections.get(senderId);
            if (pc) await pc.addIceCandidate(new RTCIceCandidate(candidate));
        }

        function handleViewerMuteStatus(payload) {
            const { viewerId, isMuted } = payload;
            if (isMuted) {
                mutedViewersLocal.add(viewerId);
                log(`ğŸ¤« è§‚ä¼— ${viewerId.substring(0,4)} è¢«ç¦è¨€ã€‚`);
            } else {
                mutedViewersLocal.delete(viewerId);
                log(`ğŸ”Š è§‚ä¼— ${viewerId.substring(0,4)} è§£é™¤ç¦è¨€ã€‚`);
            }
            updateViewerList();
        }

        // --- Controls ---
        createRoomButton.onclick = async () => {
            if (!localStream) {
                await initMedia();
                if (!localStream) return alert('æ— æ³•è®¿é—®æ‘„åƒå¤´æˆ–éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚');
            }
            const roomName = roomNameInput.value;
            if (!roomName) return alert('è¯·è¾“å…¥æˆ¿é—´å!');
            
            ws.send(JSON.stringify({ type: 'create-room', payload: { roomName } }));
        };

        stopButton.onclick = () => {
            log('â¹ï¸ æ­£åœ¨ç»“æŸç›´æ’­...');
            ws.close();
        };
        
        sendChatButton.onclick = () => {
            const text = chatInput.value;
            if (!text) return;
            
            const message = { 
                type: 'live.chat.message', 
                payload: { user: userInfo.username, text: text }
            };
            const messageString = JSON.stringify(message);

            log(`ğŸ’¬ (æˆ‘) ${text}`);
            dataChannels.forEach(dc => {
                if (dc.readyState === 'open') {
                    dc.send(messageString);
                }
            });
            chatInput.value = '';
        };

        function toggleLocalAudio(mute) {
            if (!localStream) {
                log('âš ï¸ å°šæœªè·å–åˆ°æœ¬åœ°åª’ä½“æµ!');
                return;
            }

            localStream.getAudioTracks().forEach(track => {
                track.enabled = !mute;
            });
            isAnchorMuted = mute;

            const messageType = mute ? 'live.anchor.mute' : 'live.anchor.unmute';
            const logMessage = mute ? 'ğŸ”‡ æ‚¨çš„éº¦å…‹é£å·²é™éŸ³ã€‚' : 'ğŸ”Š æ‚¨çš„éº¦å…‹é£å·²å–æ¶ˆé™éŸ³ã€‚';
            log(logMessage);

            // Notify viewers about anchor's mute status
            // This assumes the server relays this message to all viewers.
            ws.send(JSON.stringify({ type: messageType, payload: { anchorId: userInfo.persistentId, isMuted: mute } }));
        }

        muteButton.onclick = () => toggleLocalAudio(true);
        unmuteButton.onclick = () => toggleLocalAudio(false);

        async function initMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                log('âœ… æ‘„åƒå¤´å’Œéº¦å…‹é£å·²å°±ç»ªã€‚');
                // Apply initial mute state if anchor was already muted
                localStream.getAudioTracks().forEach(track => {
                    track.enabled = !isAnchorMuted;
                });
            } catch (e) {
                log(`âŒ è·å–åª’ä½“è®¾å¤‡å¤±è´¥: ${e.toString()}`);
            }
        }

        function kickUser(viewerId) {
            log(`ğŸ‘¢ æ­£åœ¨è¸¢å‡ºè§‚ä¼— ${viewerId.substring(0,4)}...`);
            ws.send(JSON.stringify({ type: 'kick-user', payload: { targetId: viewerId } }));
        }

        function toggleMuteViewer(viewerId, currentlyMuted) {
            const messageType = currentlyMuted ? 'unmute-viewer' : 'mute-viewer';
            log(`${currentlyMuted ? 'ğŸ”Š' : 'ğŸ¤«'} å‘é€æŒ‡ä»¤: ${messageType} è§‚ä¼— ${viewerId.substring(0,4)}`);
            ws.send(JSON.stringify({ type: messageType, payload: { targetId: viewerId } }));
        }

        // Initialize
        initializeUser();
        initMedia();

    </script>