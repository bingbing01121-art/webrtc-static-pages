<!DOCTYPE html>
<html>
<head>
    <title>è§‚ä¼—ç«¯ (Viewer)</title>
    <style>
        body { font-family: sans-serif; padding: 20px; background-color: #f0f2f5; color: #333; }
        h1 { color: #1a73e8; }
        video { border: 2px solid #ccc; border-radius: 8px; width: 520px; height: 390px; background: #000; display: block; margin-bottom: 15px;}
        .controls button { margin: 5px; padding: 10px 15px; border-radius: 5px; border: none; cursor: pointer; font-size: 14px; background-color: #1a73e8; color: white; }
        .controls button:hover { background-color: #155ab6; }
        #logs { white-space: pre-wrap; font-family: monospace; background: #fff; padding: 15px; border: 1px solid #ddd; border-radius: 5px; max-height: 300px; overflow-y: auto; margin-top: 20px; }
    </style>
</head>
<body>
    <h1>è§‚ä¼—ç«¯ (Viewer)</h1>
    <video id="remoteVideo" autoplay playsinline></video>
    <div class="controls">
        <button id="playButton" style="display:none;">æ’­æ”¾</button>
        <button id="pauseButton" style="display:none;">æš‚åœ (live.pause)</button>
    </div>
    <div class="controls">
        <input type="text" id="chatInput" placeholder="è¾“å…¥å¼¹å¹•...">
        <button id="sendChatButton">å‘é€å¼¹å¹•</button>
    </div>
    <h3>äº‹ä»¶æ—¥å¿—:</h3>
    <div id="logs"></div>

    <script>
        const remoteVideo = document.getElementById('remoteVideo');
        const playButton = document.getElementById('playButton');
        const pauseButton = document.getElementById('pauseButton');
        const logs = document.getElementById('logs');
        const chatInput = document.getElementById('chatInput');
        const sendChatButton = document.getElementById('sendChatButton');

        let peerConnection;
        let broadcasterId;
        let username;
        let dataChannel;
        const ws = new WebSocket('wss://live-test-a52n.onrender.com'); // Connect to public server

        function log(message) {
            console.log(message);
            logs.innerHTML += `[${new Date().toLocaleTimeString()}] ${message}\n`;
            logs.scrollTop = logs.scrollHeight;
        }

        function sendMessage(message) {
            ws.send(JSON.stringify(message));
        }

        function getUsername() {
            username = prompt("è¯·è¾“å…¥æ‚¨çš„æ˜µç§°:", `è§‚ä¼—${Math.floor(Math.random() * 1000)}`);
            if (!username) {
                username = `è§‚ä¼—${Math.floor(Math.random() * 1000)}`;
            }
            document.querySelector('h1').textContent = `è§‚ä¼—ç«¯ (${username})`;
        }
        
        getUsername();

        // --- WebSocket Event Handling ---
        ws.onopen = () => {
            log('ğŸ“¡ å·²æˆåŠŸè¿æ¥åˆ°ä¿¡ä»¤æœåŠ¡å™¨ã€‚');
            log(`ğŸ‘‹ live.audience.join â†’ ä½œä¸ºè§‚ä¼—'${username}'åŠ å…¥ç›´æ’­é—´`);
            sendMessage({ 
                type: 'register', 
                payload: { 
                    role: 'viewer',
                    username: username
                } 
            });
        };

        ws.onerror = (error) => log(`âŒ live.error â†’ WebSocket è¿æ¥é”™è¯¯: ${error.message || 'æœªçŸ¥é”™è¯¯'}ã€‚`);

        ws.onclose = () => {
            log('ğŸ”Œ ä¸ä¿¡ä»¤æœåŠ¡å™¨çš„è¿æ¥å·²æ–­å¼€ã€‚');
            if (peerConnection) {
                peerConnection.close();
            }
        };
        
        ws.onmessage = async event => {
            const message = JSON.parse(event.data);
            const { type, payload } = message;
            log(`ğŸ“© æ”¶åˆ°ä¿¡ä»¤æ¶ˆæ¯: ${type}`);

            switch(type) {
                case 'offer':
                    handleOffer(payload);
                    break;
                case 'candidate':
                    handleCandidate(payload);
                    break;
                case 'kicked':
                    log(`ğŸ‘¢ ${payload.reason}`);
                    ws.close();
                    break;
                case 'broadcaster-disconnected':
                    log('ğŸ›‘ ä¸»æ’­å·²æ–­å¼€è¿æ¥ï¼Œç›´æ’­ç»“æŸã€‚');
                    if (peerConnection) {
                        peerConnection.close();
                    }
                    remoteVideo.srcObject = null;
                    playButton.style.display = 'none';
                    pauseButton.style.display = 'none';
                    break;
                default:
                    log(`âš ï¸ æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${type}`);
            }
        };

        // --- WebRTC Core Functions ---
        async function handleOffer(payload) {
            if (peerConnection) {
                log('âš ï¸ å·²å­˜åœ¨ä¸€ä¸ª PeerConnectionï¼Œå¿½ç•¥æ–°çš„ Offerã€‚');
                return;
            }
            
            broadcasterId = payload.senderId;
            log(`ğŸ¤ æ”¶åˆ°ä¸»æ’­ ${broadcasterId} çš„ Offerï¼Œæ­£åœ¨åˆ›å»º PeerConnection...`);
            
            peerConnection = new RTCPeerConnection({ iceServers: [{urls: 'stun:stun.l.google.com:19302'}] });

            peerConnection.onconnectionstatechange = () => {
                log(`ğŸ”„ live.connection.change â†’ PeerConnection çŠ¶æ€: ${peerConnection.connectionState}`);
                if (peerConnection.connectionState === 'failed' || peerConnection.connectionState === 'disconnected') {
                    log('ğŸ›‘ live.error â†’ PeerConnection è¿æ¥å¤±è´¥æˆ–æ–­å¼€ã€‚');
                }
            };

            peerConnection.onicecandidate = e => {
                if (e.candidate) {
                    sendMessage({
                        type: 'candidate',
                        payload: {
                            targetId: broadcasterId,
                            candidate: e.candidate
                        }
                    });
                }
            };

            peerConnection.ontrack = event => {
                log('â–¶ï¸ live.play â†’ æ”¶åˆ°è¿œç¨‹åª’ä½“æµï¼Œå‡†å¤‡æ’­æ”¾ã€‚');
                if (event.streams && event.streams[0]) {
                    if (remoteVideo.srcObject !== event.streams[0]) {
                        remoteVideo.srcObject = event.streams[0];
                        playButton.style.display = 'block';
                        log('âœ… è§†é¢‘æµå·²å‡†å¤‡å¥½ï¼Œè¯·ç‚¹å‡»æ’­æ”¾æŒ‰é’®ã€‚');
                    }
                }
            };

            peerConnection.ondatachannel = event => {
                dataChannel = event.channel;
                dataChannel.onmessage = e => {
                    const msg = JSON.parse(e.data);
                    switch(msg.type) {
                        case 'live.chat.message': 
                            log(`ğŸ’¬ live.chat.message â†’ [${msg.payload.user}] ${msg.payload.text}`); 
                            break;
                        case 'live.like': 
                            log(`ğŸ‘ live.like â†’ æ”¶åˆ°æ¥è‡ª ${msg.payload.user} çš„ç‚¹èµ`); 
                            break;
                        case 'live.gift.send': 
                            log(`ğŸ live.gift.receive â†’ æ”¶åˆ°æ¥è‡ª ${msg.payload.user} çš„ç¤¼ç‰© [${msg.payload.gift}]`); 
                            break;
                        case 'live.anchor.mute': 
                            log('ğŸ”‡ live.anchor.mute â†’ ä¸»æ’­å·²é™éŸ³'); 
                            break;
                        case 'live.anchor.unmute': 
                            log('ğŸ”Š live.anchor.unmute â†’ ä¸»æ’­å·²å–æ¶ˆé™éŸ³'); 
                            break;
                        case 'moderation':
                            handleModeration(msg.payload);
                            break;
                    }
                };
                dataChannel.onopen = () => log('ğŸ’¬ æ•°æ®é€šé“å·²å¼€å¯ã€‚');
                dataChannel.onclose = () => log('ğŸ’¬ æ•°æ®é€šé“å·²å…³é—­ã€‚');
            };
            
            await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.offer));
            
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);
            
            sendMessage({
                type: 'answer',
                payload: {
                    targetId: broadcasterId,
                    answer: answer
                }
            });
            log('â¬†ï¸ å·²å°† Answer å‘é€ç»™ä¸»æ’­ã€‚');
        }

        async function handleCandidate(payload) {
            if (peerConnection) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate));
                } catch (e) {
                    log(`âš ï¸ æ·»åŠ  ICE Candidate å¤±è´¥: ${e.toString()}`);
                }
            }
        }

        function handleModeration(payload) {
            if (payload.action === 'mute-chat') {
                log('ğŸš« live.chat.moderation â†’ æ‚¨å·²è¢«ä¸»æ’­ç¦è¨€ã€‚');
                chatInput.disabled = true;
                sendChatButton.disabled = true;
            } else if (payload.action === 'unmute-chat') {
                log('âœ… live.chat.moderation â†’ æ‚¨å·²è¢«ä¸»æ’­è§£é™¤ç¦è¨€ã€‚');
                chatInput.disabled = false;
                sendChatButton.disabled = false;
            }
        }

        // --- UI Event Handlers ---
        playButton.onclick = () => {
            if (remoteVideo.srcObject) {
                remoteVideo.play().then(() => {
                    log('â–¶ï¸ live.play â†’ ç›´æ’­å·²å¼€å§‹æ’­æ”¾ã€‚');
                    playButton.style.display = 'none';
                    pauseButton.style.display = 'block';
                }).catch(error => {
                    log(`âŒ live.error â†’ æ’­æ”¾å¤±è´¥: ${error.message}`);
                });
            }
        };

        pauseButton.onclick = () => {
            if (!remoteVideo.paused) {
                remoteVideo.pause();
                log('â¸ï¸ live.pause â†’ ç›´æ’­å·²æš‚åœã€‚');
                pauseButton.textContent = 'ç»§ç»­æ’­æ”¾';
            } else {
                remoteVideo.play();
                log('â–¶ï¸ live.play â†’ ç›´æ’­å·²æ¢å¤æ’­æ”¾ã€‚');
                pauseButton.textContent = 'æš‚åœ (live.pause)';
            }
        };
        
        sendChatButton.onclick = () => {
            if (chatInput.value && dataChannel && dataChannel.readyState === 'open') {
                const message = {
                    type: 'live.chat.message',
                    payload: { user: username, text: chatInput.value }
                };
                dataChannel.send(JSON.stringify(message));
                log(`ğŸ’¬ (æˆ‘) ${chatInput.value}`);
                chatInput.value = '';
            } else {
                log('âŒ æ— æ³•å‘é€æ¶ˆæ¯ï¼Œæ•°æ®é€šé“æœªå¼€å¯æˆ–è¾“å…¥ä¸ºç©ºã€‚');
            }
        };
    </script>
</body>
</html>
